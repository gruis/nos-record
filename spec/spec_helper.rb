require "securerandom"
require "nos-record/model"
# This file was generated by the `rspec --init` command. Conventionally, all
# specs live under a `spec` directory, which RSpec adds to the `$LOAD_PATH`.
# Require this file using `require "spec_helper"` to ensure that it is only
# loaded once.
#
# See http://rubydoc.info/gems/rspec-core/RSpec/Core/Configuration
RSpec.configure do |config|
  config.treat_symbols_as_metadata_keys_with_true_values = true
  config.run_all_when_everything_filtered = true
  config.filter_run :focus

  # Run specs in random order to surface order dependencies. If you find an
  # order dependency and want to debug it, you can fix the order by providing
  # the seed, which is printed after each run.
  #     --seed 1234
  config.order = 'random'
end

module NosRecord
  module Test
    class ModelClass
      include ::NosRecord::Model
      attr_accessor :id
      attr_accessor :attr1
      attr_accessor :attr2
    end
    class AnotherModelClass < ModelClass

    end
  end
end

shared_examples_for "a connection" do
  it { connection.should respond_to(:each) }
  it { connection.should respond_to(:save) }
  it { connection.should respond_to(:delete) }
  it { connection.should respond_to(:get) }
  it { connection.should respond_to(:open) }
  it { connection.should respond_to(:close) }
  it { connection.method(:get).arity.should == 2 }
  it { connection.method(:save).arity.should == 1 }
  it { connection.method(:delete).arity.should == 1 }
  it { connection.method(:open).arity.should == 0 }
  it { connection.method(:close).arity.should == 0 }
  it { connection.method(:each).arity.should == -1 }
  let(:modelA) do
    NosRecord::Test::ModelClass.new.tap do |m|
      m.id = SecureRandom.hex
      m.attr1 = SecureRandom.hex
    end
  end
  let(:modelB) do
    NosRecord::Test::ModelClass.new.tap do |m|
      m.id = SecureRandom.hex
      m.attr1 = SecureRandom.hex
    end
  end
  let(:anotherModelA) do
    NosRecord::Test::AnotherModelClass.new.tap do |m|
      m.id = SecureRandom.hex
      m.attr1 = SecureRandom.hex
    end
  end
  context "storing objects" do
    context "#save" do
      it "should return the connection" do
        connection.save(modelA).should.should == connection
      end
    end
  end
  context "retrieving objects" do
    before(:each) do
      connection.save(modelA)
      connection.save(modelB)
      connection.save(anotherModelA)
    end
    context "#get" do
      it "should retrieve the object" do
        connection.get(modelA.id, modelA.class)
      end
      it "should return nil if the object doesn't exist" do
        connection.get(SecureRandom.hex, modelA.class).should be_nil
      end
    end
    context "#each" do
      it "should return an Enumerator" do
        connection.each.should be_an Enumerator
      end
      it "should contain all objects" do
        connection.select{|o| o.respond_to?(:id) }.map(&:id).should include(modelA.id)
        connection.select{|o| o.respond_to?(:id) }.map(&:id).should include(modelB.id)
        connection.select{|o| o.respond_to?(:id) }.map(&:id).should include(anotherModelA.id)
      end
      it "should filter on class when given a class argument" do
        modelA.id.should_not == anotherModelA.id
        filtered = connection.each(modelA.class).map(&:id)
        filtered.should_not include(anotherModelA.id)
        filtered.should include(modelB.id)
        filtered.should include(modelA.id)
      end
      it "should filter on classes that inherit from other model classes" do
        filtered = connection.each(anotherModelA.class).map(&:id)
        filtered.should include(anotherModelA.id)
        filtered.should_not include(modelB.id)
        filtered.should_not include(modelA.id)
      end
    end
  end
end

shared_examples_for "a model class" do
  it { model_class.should respond_to(:default_connection) }
  pending { it { model_class.should respond_to(:default_connection=) } }
  it { model_class.should respond_to(:each) }
  it { model_class.should respond_to(:get) }
  it { model_class.should respond_to(:find_by_attr) }
  it { model_class.method(:get).arity.should == -2 }
  it { model_class.method(:each).arity.should == -1 }
  it { model_class.method(:find_by_attr).arity.should == -3 }
  it "should be referenced in Model.models" do
    NosRecord::Model.models.should include(model_class)
  end

  context "#new" do
    let(:model) { model_class.new }
    it_behaves_like "a model instance"
    describe "#save" do
      let(:connection) { NosRecord::Connection::Sqlite.new(":memory:") }
      let(:connection2) { NosRecord::Connection::Sqlite.new(":memory:") }
      it { model.method(:save).arity.should == -1 }
      it "should raise an error when an id is not set" do
        model.id.should be_nil
        expect { model.save }.to raise_error(NosRecord::IdRequired)
      end
      it "should fail without a connection" do
        model.id = SecureRandom.hex
        model.id.should_not be_nil
        model._connection.should be_nil
        expect {
          model.save
        }.to raise_error(NosRecord::ConnectionRequired)
      end
      it "should accept a connection" do
        model.id = SecureRandom.hex
        connection.get(model.id, model.class).should be_nil
        model.save(connection).should == model
        connection.get(model.id, model.class).should be_a model_class
        connection.get(model.id, model.class).id.should == model.id
        connection2.get(model.id, model.class).should be_nil
      end
    end
  end
end

shared_examples_for "a model instance" do
  it { model.should respond_to(:save) }
  it { model.should respond_to(:delete) }
  it { model.method(:delete).arity.should == -1 }
end
